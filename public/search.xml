<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android IPC基础概念]]></title>
    <url>%2F2017%2F07%2F26%2FAndroid%20IPC%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[关于IPC主要包含三方面的内容: Serializable接口, Parcelable接口, 以及Binder Serializable接口]]></content>
      <categories>
        <category>Android</category>
        <category>IPC</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android IPC机制简介]]></title>
    <url>%2F2017%2F07%2F26%2FAndroid%20IPC%E6%9C%BA%E5%88%B6%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[IPC是什么IPC是Inter-Process Communication缩写,含义为进程间通信. 按照操作系统中的描述,线程是cpu调度的最小单元,而进程一般指一个执行单元. 进程中可以有一个或者多个线程. 不同的操作系统有着不同的IPC机制: Windows: 通过剪切板, 管道, 信号量来进行进程间通信 Linux: 通过命名管道, 共享内存, 信号量等来进行进行进程间通信 android: 虽然基于Linux内核,但是使用了独有的Binder机制, 也可以Socket进行通信 这里解释一下定义（来自百度百科） 剪切板：剪切板是指windows 操作系统提供的一个暂存数据，并且提供共享的一个模块。也称为数据中转站，剪切板在后台起作用，在内存里.，是操作系统设置的一段存储区域，你是在硬盘里找不到的.你只要有文本输入的地方按CTRL+V或右键粘贴就出现了，.新的内容送到剪切板后，将覆盖旧内容。 管道：管道是两个头的东西，每个头各连接一个进程或者同一个进程的不同代码，按照管道的类别分有两种管道，匿名的和命名的；按照管道的传输方向分也可以分成两种，单向的双向的。根据管道的特点，命名管道通常用在网络环境下不同计算机上运行的进程之间的通信（当然也可以用在同一台机的不同进程中）它可以是单向或双向的；而匿名管道只能用在同一台计算机中，它只能是单向的。匿名管道其实是通过用给了一个指定名字的有名管道来实现的。使用管道的好处在于：读写它使用的是对文件操作的 api，结果操作管道就和操作文件一样。即使你在不同的计算机之间用命名管道来通信，你也不必了解和自己去实现网络间通信的具体细节。 信号量信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。为了完成这个过程，需要创建一个信号量VI，然后将Acquire Semaphore VI以及Release Semaphore VI分别放置在每个关键代码段的首末端。确认这些信号量VI引用的是初始创建的信号量。 共享内存共享内存是进程间通信中最简单的方式之一。共享内存允许两个或更多进程访问同一块内存，就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。因为所有进程共享同一块内存，共享内存在各种进程间通信方式中具有最高的效率。 使用场景:可能有些模块因为特殊原因需要运行在单独的进程中; 或者为了加大一个应用可使用的内存; 又或者我们需要去另外一个进程去获取数据,必然需要跨进程.]]></content>
      <categories>
        <category>Android</category>
        <category>IPC</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的多进程的模式]]></title>
    <url>%2F2017%2F07%2F26%2FAndroid%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[开启多进程模式如果你想在一个应用中使用多个进程,通过清单文件给四大组件添加android:process属性,就可以很方便的开启多进程.还有一种非常规的创建方式,通过JNI在native层去fork一个新的进程.这种我们暂时只是了解一下. 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.wudi.demo"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".FristActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".SecondActivity" android:process=":second"&gt; &lt;/activity&gt; &lt;activity android:name=".ThirdActivity" android:process="com.third.demo"&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 当我们依次打开FristActivity, SecondActivity, ThirdActivity.此时应该打开了三个进程. 那么命令行中进行测试adb shell ps可以把系统所有进程展示出来, 你可以加上过滤信息| grep xxx xxx替换你需要过滤出来信息,这里我们使用adb shell ps | grep com.wudi,结果为： 123u0_a512 13555 533 1715032 47068 SyS_epoll_ 0000000000 S com.wudi.demou0_a512 13585 533 1715032 47208 SyS_epoll_ 0000000000 S com.wudi.demo:secondu0_a512 13625 533 1894268 61276 SyS_epoll_ 0000000000 S com.wudi.third 这里需要注意的是： 当以:开头的进程,属于当前应用的私有进程,其他应用的组件不可以和它跑在同一个进程 当不以:开头,那么进程属于全局进程,其他应用通过ShareUID方法可以和它跑在同一个进程 Android系统会为每一个应用分配唯一的UID. 相同UID的应用才能共享数据. 但是两个应用通过ShareUID跑在同一个进程是有要求的. 除了具有相同的ShareUID并且还要签名相同才可以. 这时如果不在同一进程他们之间可以共享data目录,组件信息等. 如果还在同一进程, 那么他们还能共享内存数据. 进程模式的运行机制两个进程间,每个单独的进程又会分配一个独立的虚拟机, 所以每个虚拟机在内存分配上有不同的地址空间.对于不同虚拟机访问同一个对象就会产生多份副本. 副本之间互相独立不干扰彼此. 我们需要注意的问题 静态成员和单例模式完全失效 线程同步机制完全失效 SharedPreferences的可靠性下降 Application会多次创建 1.如果在FristActivity中对静态变量进行修改, 在SecondActivity取出这个静态发现是FristActivity没修改之前的.2.因为不是一块内存,所以不管是锁对象还是锁全局都无法保证线程同步,因为不是同一个对象.3.因为Sp不支持两个进程同时读写,因为底层是通过读写XML文件实现的,并发可能会触发异常.4.运行在多个进程中,那么就会创建多个虚拟机,每个虚拟机都有一个对应Application并需要启动加载这个文件. 一个应用的多进程:它就相当于两个不同的应用采用了ShareUID的模式. 每个进程都会拥有独立的虚拟机, Application以及内存空间]]></content>
      <categories>
        <category>Android</category>
        <category>IPC</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android调起照相机、相册获取图片，并压缩图片]]></title>
    <url>%2F2017%2F07%2F25%2FAndroid%E8%B0%83%E8%B5%B7%E7%85%A7%E7%9B%B8%E6%9C%BA%E3%80%81%E7%9B%B8%E5%86%8C%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%EF%BC%8C%E5%B9%B6%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[最近封装了图片OCR模块，模块代码不方便贴出来，就简单记录一下图片的处理方式获取图片方式是让用户选择 相机拍照 或者从 相册 中选择 先说照相机方式： 首先考虑Android6.0之后的动态权限处理123456789101112131415161718192021222324252627282930313233343536373839404142/** * 核对相机权限 */ private void checkCameraPermission() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; try &#123; int isPermission = checkSelfPermission(Manifest.permission.CAMERA); if( isPermission == PackageManager.PERMISSION_GRANTED) &#123; openCarema(); return; &#125; boolean shouldRequest = shouldShowRequestPermissionRationale(Manifest.permission.CAMERA); if (shouldRequest) &#123; requestCameraPermission(); return; &#125; showToast("请打开摄像机权限"); &#125; catch (RuntimeException e) &#123; //防止MUNU系统等，更改权限的名称 showToast("请打开摄像机权限"); &#125; &#125; else &#123; openCarema(); &#125; &#125; /** * 请求打开权限 */ @TargetApi(Build.VERSION_CODES.M) private void requestCameraPermission() &#123; requestPermissions(new String[]&#123;Manifest.permission.CAMERA&#125;, REQUESTCODE_OPEN_CAMERA_PERMISSION); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; if (requestCode == REQUESTCODE_OPEN_CAMERA_PERMISSION) &#123; if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; openCarema(); &#125; else &#123; showToast("请打开摄像机权限"); &#125; &#125; &#125; 上边代码很简单明了，这里就不做赘述了 下边打开相机123456789101112131415161718192021222324/** * 打开相机 */ private void openCarema() &#123; // 指定相机拍摄照片保存地址 String state = Environment.getExternalStorageState(); if (state.equals(Environment.MEDIA_MOUNTED)) &#123; cameraPath = SAVED_IMAGE_DIR_PATH + System.currentTimeMillis() + ".png"; Intent intent = new Intent(); // 指定开启系统相机的Action intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE); String out_file_path = SAVED_IMAGE_DIR_PATH; File dir = new File(out_file_path); if (!dir.exists()) &#123; dir.mkdirs(); &#125; // 把文件地址转换成Uri格式 Uri uri = Uri.fromFile(new File(cameraPath)); // 设置系统相机拍摄照片完成后图片文件的存放地址 intent.putExtra(MediaStore.EXTRA_OUTPUT, uri); startActivityForResult(intent, CAMERA_REQUEST_CODE); &#125; else &#123; showToast("请确认已经插入SD卡"); &#125; &#125; 上面可以看到，开启系统现有相机应用拍摄照片，需要用的MediaStore.ACTION_IMAGE_CAPTURE作为Intent的action开启Activity即可。但是在使用系统现有相机用用的时候，默认会把图片保存到系统图库的目录下，如果需要指定图片文件的保存路径，需要额外在Intent中设置。 设置系统现有相机应用的拍摄照片的保存路径，需要用Intent.putExtra()方法通过MediaStore.EXTRA_OUTPUT去设置Intent的额外数据，这里传递的是一个Uri参数，可以是一个文件路径的Uri。 如果得到结果的话，我们在讲完打开相册后再说 相册方式12345//打开相册Intent intent = new Intent(Intent.ACTION_PICK, null);intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, "image/*");intent.setAction(Intent.ACTION_GET_CONTENT);startActivityForResult(intent, ALBUM_REQUEST_CODE); 处理返回结果1234567891011121314151617181920212223242526272829303132333435363738@Override public void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); Bitmap bitmap = null; if (resultCode == Activity.RESULT_OK) &#123; switch (requestCode) &#123; case CAMERA_REQUEST_CODE: if (TextUtils.isEmpty(cameraPath)) &#123; showToast("获取摄像机图片失败"); return; &#125; bitmap = BitmapUtils.getSmallBitmap(cameraPath, 480, 640); Logger.d("path=" + cameraPath); File file = new File(cameraPath); if (file.exists()) &#123; file.delete(); Logger.d("删除相机图片"); &#125; break; case ALBUM_REQUEST_CODE: Uri uri = data.getData(); final String absolutePath= getAbsolutePath(this, uri); if (TextUtils.isEmpty(absolutePath)) &#123; showToast("获取摄像机图片失败"); return; &#125; bitmap = BitmapUtils.getSmallBitmap(absolutePath, 480, 640); break; default: break; &#125; if (bitmap == null) &#123; showToast("获取图片失败"); return; &#125; fillBitmap(bitmap); &#125; &#125; 由上边可知BitmapUtils.getSmallBitma是得到压缩之后的图片，下边放代码123456789101112131415161718/** * 根据路径获得突破并压缩返回bitmap用于显示 * 作者：QianqianLis * 链接：http://www.jianshu.com/p/81e553fd0bc3 * 來源：简书 * @param filePath * @return */public static Bitmap getSmallBitmap(String filePath, int reqWidth, int reqHeight) &#123; final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; //只返回图片的大小信息 BitmapFactory.decodeFile(filePath, options); // Calculate inSampleSize options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); // Decode bitmap with inSampleSize set options.inJustDecodeBounds = false; return BitmapFactory.decodeFile(filePath, options);&#125; 这是从简书上看到的方法，只是做了一个简单的封装就使用了，亲自分别保存了压缩前的的图片和压缩后的图片，做了一下对比，红米note4上原图3M压缩完800k，当然这只是大概数据]]></content>
      <categories>
        <category>Android</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流程图示例]]></title>
    <url>%2F2017%2F07%2F13%2F%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[欢迎使用马克飞象@(示例笔记本)[马克飞象|帮助|Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： [x] 已完成事项 [ ] 待办事项1 [ ] 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#x68;&#x75;&#115;&#116;&#103;&#111;&#99;&#x6b;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。]]></content>
      <categories>
        <category>Android</category>
        <category>交互</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 关于 so 所需要了解的]]></title>
    <url>%2F2017%2F04%2F14%2FAndroid%20%E5%85%B3%E4%BA%8E%20so%20%E6%89%80%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%2F</url>
    <content type="text"><![CDATA[什么是so文件： so是Shared Object的缩写，即共享的对象，机器可以直接运行的二进制码， 从操作系统到专用软件，都离不开so。 so文件主要用于Unix和Linux系统中。 .a和.so对比 .a:archive 存档的含义，是unix系统中对于静态库的文件后缀，在软件打包时和主程序表态链接在一起，表现形式是在链接成同一个文件。 go lang即广泛采用这一形式，对于软件分发只有一个文件。对于打包好的软件来讲，这是专属库，所有都在出厂前打包在一起了，好处是不受外界影响，坏处是任何改动要全部分发。 对于安装应用的系统来讲，当然是共享的越多越好，既省内存又省硬盘。 .so:shared object 共享库，用过Windows的同学应该都或多或少碰到过找不到DLL或DLL错误之类的问题，其中最为著名的问题就是DLL Hell（某个著名的库，软件a使用1.0，新装的软件b使用1.0.1，导致软件a运行异常），DLL即Dynamic Link Library的缩写，和shared object表示同样的事物，只是名字不同而已。 运行时按需加载，不论是系统提供的共享库还是自带的共享库，最大化利用软件分治的原理，修Bug也是更新所在so文件，不需全部更新。 Android中的so so是与平台相关的二进制机器码，与ABI（Application Binary Interface）相对应， 一个ABI表示相应的CPU的指令集与内存页管理，也对应于不同的C运行环境，所以so是有不同的系统版本的。 随着Android系统的快速发展，搭载Android的硬件平台也早已多样化了（对比WinTel联盟，直到2012年才新发展了Windows RT来适配ARM平台，2015年的Win10才进入 Raspberry Pi 2这类基于ARM的新型设备中）， 现在已经运行在7个ABI：armeabi，armeabi-v7a (armeabi-v7a-hard)，arm64-v8a，x86，x86_64，mips 和 mips64。 Android为什么选择使用so Android 是基于 Linux Kernl，同样也继承了所有so的相关设计。 除了系统原因，还有一下几点： 1. so机制能够让开发者最大化利用己有的C 和 C++代码 2.so比java执行速度快 3.内存分配不受Dalivik/ART的单个应用限制，减少OOM 如何使用 Android Studio中。将得到的ABI放到jniLibs/API ├── AndroidManifest.xml └── jniLibs ├── armeabi │ └── libsnappydb-native.so ├── armeabi-v7a │ └── libsnappydb-native.so ├── mips │ └── libsnappydb-native.so └── x86 └── libsnappydb-native.so - 或者使用jniLibs.srcDir属性指定： android { sourceSets { main { jni.srcDirs = [] //disable automatic ndk-build call jniLibs.srcDir &apos;main/libs&apos; } } } - eclipse中直接放到libs/ABI目录。 - 在aar文件中，so处于jni/ABI目录中，对于库开发者和应用开发者都不必关注，全部自动处理。 - 在生成的APK中，所有so文件对应于lib/ABI中。 - 当APK安装到Android系统中时，so文件位置: Android&lt;5.0，/data/data/PACKAGE_NAME/lib Android&gt;=5.0，/data/app/PACKAGE_NAME/lib/CPU_ARCH/和/data/data/PACKAGE_NAME/lib 可能出现的问题 UnsatisfiedLinkError dlopen：falied]]></content>
      <categories>
        <category>Android</category>
        <category>NDK开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android热修复技术之Java代理模式]]></title>
    <url>%2F2017%2F03%2F28%2FAndroid%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E4%B9%8BJava%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概念代理模式是一种比较常用的设计模式，一般来说，当我们不想或者不能直接访问一个对象A，必须通过一个中介对象B来访问，这种方式就叫做代理模式。 优点 隐藏委托类的实现，调用者需要和代理类交互 解耦，在不改变委托类代码情况下可以做一些额外处理。 区分 静态代理 代理类的字节码文件，代理类和委托类的关系 在运行之前就已经确定了。 代理接口定义： public interface Subject { void m1(); void m2(); } 代理委托者，实现了代理接口： public class RealSubject implements Subject{ @Override public void m1() { SystemClock.sleep(1000); Log.d(&quot;DEBUG&quot;,&quot;##### call method 1&quot;); } @Override public void m2() { SystemClock.sleep(2000); Log.d(&quot;DEBUG&quot;,&quot;##### call method 2&quot;); } } 代理类： public class ProxySubject implements Subject { //引用真正的实现类 private RealSubject subject; @Override public void m1() { log(); if (null == subject) { subject = new RealSubject(); } subject.m1(); } @Override public void m2() { if (null == subject) { subject = new RealSubject(); } subject.m2(); log(); } private void log() { Log.d(&quot;DEBUG&quot;, &quot;### log it&quot;); } } 代理类通过引用，去调用真实对象的方法，在代理类方法中可以加入一些其他操作，比如日志操作等。 动态代理 当我们遇到要代理的方法比较多。比方说，我们在接口中增加一个方法，除了委托类要实现这个方法，代理类也要实现这个方法，感觉上就非常难受。 那我们就需要一个代理类完成所有的代理功能，或者动态的生成代理类，就需要动态代理。 实现步骤 创建一个实现InvocationHandler的类，实现invoke方法 通过Proxy的newProxyInstance创建一个代理 创建代理类的接口 通过代理调用方法 - 根据步骤我们分别创建Subject和RealSubject Subject： package ProxyMode; /* * 抽象接口，对应类图中的Subject * */ public interface Subject { public void SujectShow(); } RealSubject： package ProxyMode; public class RealSubject implements Subject{ @Override public void SujectShow() { // TODO Auto-generated method stub System.out.println(&quot;我才是真正的操作，我是黑衣人！By---&quot;+getClass()); } } - 建立InvocationHandler用来响应代理的任何调用 package ProxyMode; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class ProxyHandler implements InvocationHandler { private Object proxied; public ProxyHandler( Object proxied ) { this.proxied = proxied; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;准备工作之前：&quot;); //转调具体目标对象的方法 Object object= method.invoke( proxied, args); System.out.println(&quot;工作已经做完了！&quot;); return object; } } - 测试 package ProxyMode; import java.lang.reflect.Proxy; public class DynamicProxy { public static void main( String args[] ) { RealSubject real = new RealSubject(); Subject proxySubject = (Subject)Proxy.newProxyInstance(Subject.class.getClassLoader(), new Class[]{Subject.class}, new ProxyHandler(real)); proxySubject.SujectShow();; } } - 测试结果 准备工作之前： 我才是真正的操作，我是黑衣人！By---class ProxyMode.RealSubject 工作已经做完了！]]></content>
      <categories>
        <category>Android</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown编写流程图的语法问题]]></title>
    <url>%2F2017%2F03%2F27%2FMarkDown%E7%BC%96%E5%86%99%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E8%AF%AD%E6%B3%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[画流程图的步骤 好气哦！我的编辑器不支持解析！ :( 后头搞一下，未完待续… 第一段用来定义元素 语法： tag=&gt;type:content:&gt;url tag就是一个标签，下面我们在定义连接元素时用type是这个标签的类型 基本类型： start end operation subroutine condition input/output 开始： st=&gt;start:开始 操作流程： st-&gt;op-&gt;cond 条件： cond=&gt;condition:确认? 结束： e=&gt;end:结束 示例： st=&gt;start: Start|past:&gt;http://www.google.com[blank]e=&gt;end: End:&gt;http://www.google.comop1=&gt;operation: My Operation|pastop2=&gt;operation: Stuff|currentsub1=&gt;subroutine: My Subroutine|invalidcond=&gt;condition: Yesor No?|approved:&gt;http://www.google.comc2=&gt;condition: Good idea|rejectedio=&gt;inputoutput: catch something…|requestst-&gt;op1(right)-&gt;condcond(yes, right)-&gt;c2cond(no)-&gt;sub1(left)-&gt;op1c2(yes)-&gt;io-&gt;ec2(no)-&gt;op2-&gt;e st=&gt;start: Start e=&gt;end op=&gt;operation: My Operation cond=&gt;condition: Yes or No? st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op 第二段用来连接元素 st=&gt;start:开始 st-&gt;op-&gt;cond flow st=&gt;start: Start op=&gt;operation: Your Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op ～～～flowst=&gt;start: Start:&gt;http://alfred-sun.github.ioio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;end:&gt;https://github.com/adrai/flowchart.js st-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io～～～ st=&gt;start: 开始:&gt;http://www.google.com[blank] e=&gt;end: 结束:&gt;http://www.google.com op1=&gt;operation: 操作 sub1=&gt;subroutine: 子程序 cond=&gt;condition: Yes or No?:&gt;http://www.google.com io=&gt;inputoutput: 输入输出 st-&gt;op1-&gt;cond cond(yes)-&gt;io-&gt;e cond(no)-&gt;sub1(right)-&gt;op1 st=&gt;start: Start:&gt;http://alfred-sun.github.ioio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;end:&gt;https://github.com/adrai/flowchart.jsst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io]]></content>
      <categories>
        <category>Markdown</category>
        <category>流程图</category>
      </categories>
      <tags>
        <tag>Text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSpcript常用互动方法]]></title>
    <url>%2F2017%2F01%2F16%2FJavaSpcript%E5%B8%B8%E7%94%A8%E4%BA%92%E5%8A%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.输出内容document.write() 可用于直接向HEML输出流写内容。简单的说就是直接在网页中输出内容 1.1 第一种：输出内容用“”括起，直接输出“”号内的内容 &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;I love JavaScript！&quot;); //内容用&quot;&quot;括起来，&quot;&quot;里的内容直接输出。 &lt;/script&gt; 1.2 第二种：通过变量，输出内容 &lt;script type=&quot;text/javascript&quot;&gt; var mystr=&quot;hello world!&quot;; document.write(mystr); //直接写变量名，输出变量存储的内容。 &lt;/script&gt; 1.3 第三种：输出多项内容，内容之间用+连接 &lt;script type=&quot;text/javascript&quot;&gt; var mystr=&quot;hello&quot;; document.write(mystr+&quot;I love JavaScript&quot;); //多项内容之间用+号连接 &lt;/script&gt; 1.4 第四中：输出HTML标签，并起作用，标签使用“”括起来 &lt;script type=&quot;text/javascript&quot;&gt; var mystr=&quot;hello&quot;; document.write(mystr+&quot;&lt;br&gt;&quot;);//输出hello后，输出一个换行符 document.write(&quot;JavaScript&quot;); &lt;/script&gt; 注意： 空格使用&amp;nbsp; 2.alert消息对话框我们在访问网站的时候，有时候会突然弹出一个小窗口，上面写着一段提示文字。 语法： alert(字符串或变量); demo： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;alert&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function rec(){ var mychar=&quot;I love JavaScript&quot;; alert(mychar); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input name=&quot;button&quot; type=&quot;button&quot; onClick=&quot;rec()&quot; value=&quot;点击我，弹出对话框&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 3.confirm消息对话框confirm消息对话框通常用于允许用户做选择的动作，如：“你对吗”等，弹出对话框（包括一个确定按钮和一个取消按钮） 语法： confirm(str); 参数说明： str：在消息对话框中要显示的文本 返回值: Boolean值 返回值： 当用户点击&quot;确定&quot;按钮时，返回true 当用户点击&quot;取消&quot;按钮时，返回false demo： &lt;script type=&quot;text/javascript&quot;&gt; var mymessage=confirm(&quot;你喜欢JavaScript吗?&quot;); if(mymessage==true) { document.write(&quot;很好,加油!&quot;); } else { document.write(&quot;JS功能强大，要学习噢!&quot;); } &lt;/script&gt; 注意： 消息对话框是排斥其他操作的，即用户在点击对话框按钮前，不能进行任何其它的操作 4.prompt消息对话框prompt弹出消息对话框，通常用于询问一些需要与用户交互的信息，弹出消息对话框（包含一个确定按钮，取消按钮与一个文本输入框） 语法： prompt(str1, str2); 参数说明： str1: 要显示在消息对话框中的文本，不可修改 str2：文本框中的内容，可以修改 返回值： 1. 点击确定按钮，文本框中的内容将作为函数返回值 2. 点击取消按钮，将返回null demo： var myname=prompt(&quot;请输入你的姓名:&quot;); if(myname!=null) { alert(&quot;你好&quot;+myname); } else { alert(&quot;你好 my friend.&quot;); } 5.打开新窗口window.openopen()方法可以查找一个已经存在或者新建的浏览器窗口 语法： window.open([URL], [窗口名称], [参数字符串]) 参数说明： URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。 窗口名称：可选参数，被打开窗口的名称。 1.该名称由字母、数字和下划线字符组成。 2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。 _blank：在新窗口显示目标网页 _self：在当前窗口显示目标网页 _top：框架网页中在上部窗口中显示目标网页 3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。 4.name 不能包含有空格。 参数字符串： 可选参数，设置窗口参数，各参数用逗号隔开。 6.关闭窗口window.closeclose()关闭窗口 用法： window.close(); //关闭本窗口 或 &lt;窗口对象&gt;.close(); //关闭指定的窗口 demo： &lt;script type=&quot;text/javascript&quot;&gt; var mywin=window.open(&apos;http://www.imooc.com&apos;); //将新打的窗口对象，存储在变量mywin中 mywin.close(); &lt;/script&gt;]]></content>
      <categories>
        <category>JS</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程登录服务器]]></title>
    <url>%2F2016%2F09%2F10%2F%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[SSH协议原理 对称加密算法： 采用单钥密码系统的加密方法，同一个秘钥可以同时用作信息的加密和解密，这种加密方法成为对称加密，也称为单秘钥加密 非对称加密算法： 又名“公开秘钥加密算法”，非对称加密算法需要两个秘钥：公开秘钥和私有秘钥 ssh 用户名@ip 远程登录指定Linux服务器 scp [-r] 用户名@ip：文件路径 本地路径 下载文件 scp [-r] 本地文件 用户名@ip：上传路径 上传文件 SecureCRT远程管理工具 windows平台管理linux服务器，收费 Xshell工具 windows平台管理linux服务器，免费]]></content>
      <categories>
        <category>计算机网络</category>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View之事件分发机制]]></title>
    <url>%2F2016%2F08%2F27%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Q：为什么有时间分发机制？ A：安卓View是树形结构，会重叠在一起，为了处理点击，滑动等交互冲突 未完待续…]]></content>
      <categories>
        <category>Android</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux网络基础之网络模型]]></title>
    <url>%2F2016%2F08%2F15%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[ISO/OSI七层模型* iso：国际标准化组织 * osi：开放系统互联模型 是TCP/IP四层模型的基础 从低到高依次：物理层 数据链路层 网络层 传输层（下四层实际传输） 会话层 表示层 应用层（上三层给用户服务） 物理层：传输单位比特，真正的数据传输 数据链路层：传输单位帧，这里边包含MAC地址（物理地址，计算机网卡的硬件地址） 网络层：报文，这里边包含IP地址（逻辑地址） 传输层：数据段 TPDU（传输协议传输协议） 会话层：SPDU(会话协议传输地址) 表示层：PPDU（表示协议传输地址） 应用层：APDU（应用协议传输地址） 七层模型： TCP/IP四层模型TCP/IP模型与OSI参考模型的对应关系： tcp/ip模型与osi模型的比较： 共同点： osi参考模型和tcp/ip参考模型都采用了层次结构的概念 都能提供面向连接和无连接两种通信服务机制 不同点： 前者是七层模型，后者是四层结构 对可靠性要求不同（后者更高） osi模型是在协议开发前设计的，具有通用性，tcp/ip是先有协议然后建立模型，不适用于非tcp/ip网络 实际市场应用不同（osi是理论上的模型，并没有成熟的产品，而tcp/ip已经成为“实际上的国际标准”）]]></content>
      <categories>
        <category>计算机网络</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP地址，子网掩码，端口，DNS，网关]]></title>
    <url>%2F2016%2F08%2F15%2FIP%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%EF%BC%8C%E7%AB%AF%E5%8F%A3%EF%BC%8CDNS%EF%BC%8C%E7%BD%91%E5%85%B3%2F</url>
    <content type="text"><![CDATA[IP地址IP包头： IP地址： 00000000.00000000.00000000.00000000 1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 换算成为： 0.0.0.0 255.255.255.255 IP地址分类： 子网掩码ip和子网掩码不能单独使用，必须一起使用（不能分开查看，要一起查看） 标准子网掩码： 255.0.0.0 255.255.0.0 255.255.255.0 表示对应的数变化就是不同网段，需要路由器才能相互访问，其他的变化没关系，还是同一个网段 A类IP： B类IP： C类IP： 变长子网掩码及子网规划: 端口在传输层确定端口号 通过ip能确定对方服务器位置，服务器上开启了一些服务，不同服务有不同的端口号，端口号就是为了确定目标服务器相应的服务 端口号 2的16次方 0 - 65535 TCP协议包头： UDP协议包头： 常见端口号： * FTP（文件传输协议）端口号：20 21 * SSH（安全shell协议）：端口号 22 * telnet（远程登录协议）：端口号 23（禁用，明文传输） * DNS（域名系统）：端口号53 * http（超文本传输协议）：端口号80 * SMTP（简单邮件传输协议）：端口号25 * POP3（邮局协议3代）：端口号 110 查看本机启用的端口命令： netstat -an -a：查看所有连接和监听端口 -n：显示IP地址和端口号，而不显示域名和服务名 DNS不配置DNS是不能访问互联网的 Domain Name System的缩写，域名系统的缩写，又叫名称解析 名称解析概述 * 在互联网中，通过IP地址来进行通信 * IP地址用数字表示，记忆起来比较困难 * 人对域名更加敏感 在DNS出现之前，我们有hosts文件（静态IP和域名对应），优先级比DNS更高 从Hosts文件到DNS 早期Hosts文件解析域名 名称解析效能下降 主机维护困难 DNS服务 层次性 分布式 DNS服务的作用 将域名解析为IP地址 1. 客户机向DNS服务器发送域名查询请求 2. DNS服务器告知客户机Web服务器的IP地址 3. 客户机与Web服务器通信 域名空间结构 根域 顶级域（域名分配组织ISO分配） 组织域（gov政府，com商业，edu教育，org民间组织，net网络服务，mil军事） 国家或地区域(cn中国，hk香港，jp日本，uk英国，au澳大利亚) 二级域 主机名 DNS查询过程 DNS查询类型 从查询方式上区分 递归查询：要么做出查询成功响应，要么作出查询失败的响应，一般客户机和服务器之间属于递归查询，即当客户机向DNS服务器发出请求后，若DNS服务器本身不能解析，则会向另外的DNS服务器发出查询请求，得到结果后转交给客户机 迭代查询：服务器收到一次迭代查询回复一次结果，这个结果不一定是目标IP与域名的映射关系，也可以是其他DNS服务器的地址 从查询内容上区分 正向查询由域名查找IP地址 反向查询由IP地址查找域名 网关概念： 网关（Gateway）又称网间连接器，协议转换器 网关在网络层以上实现网络互联，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互联 网管既可以用于广域网互联，也可以用于局域网互联。 网关是一种充当转换重任的服务器或路由器 示意图：]]></content>
      <categories>
        <category>计算机网络</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现WebView中网页与App的Activity跳转]]></title>
    <url>%2F2016%2F08%2F13%2F%E5%AE%9E%E7%8E%B0WebView%E4%B8%AD%E7%BD%91%E9%A1%B5%E4%B8%8EApp%E7%9A%84Activity%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[介绍三种实现方式: 1. 通过JS来实现 2. 通过scheme来实现(不支持webview的重定向) 3. 通过webview的重定向（setWebViewClient（WebView view,String url）{})方法中对url判断，隐式意图打开Activity 1.通过JS 只需要三个步骤: * WebView开启JavaScript脚本执行。 * WebView设置供JavaScript调用的交互接口。 * 客户端和网页端编写调用对方的代码。 写了两遍都没保存上，恼火…什么时候想起来什么时候补吧 2.通过scheme（Deep Linking深度链接，可以自行查资料https://www.linkedme.cc/） 在html中，设置链接 &lt;a href=&quot;myscheme://host：8080/path/?action=com.example.wudi.webviewdemo.baginfo&amp;id=123&quot;&gt; Take a QR code &lt;/a&gt; &lt;!--bagin 下面介绍各个部分: &quot;myscheme&quot;:scheme &quot;host&quot;:host主机 &quot;8080&quot;:post端口号 &quot;path&quot;:path路径 &quot;action&quot;=com.example.wudi.webviewdemo.baginfo&amp;id=123:params参数 --&gt; 然后我们在清单文件中需要给要打开的activity设置intent-filter的scheme(scheme:计划；组合；体制；诡计)，其中scheme必须和链接中scheme保持一致,host可写可不写，自行忽略 &lt;activity android:name=&quot;.DemoActivity&quot;&gt; &lt;!— URI Scheme方式 -—&gt; &lt;intent-filter&gt; &lt;data android:scheme=&quot;myscheme&quot; /&gt; &lt;data android:host=&quot;host&quot;/&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;!--&lt;data android:host=&quot;&quot; android:mimeType=&quot;&quot; android:path=&quot;&quot; android:pathPattern=&quot;&quot; android:pathPrefix=&quot;&quot; android:port=&quot;&quot; android:scheme=&quot;&quot; android:ssp=&quot;&quot; android:sspPattern=&quot;&quot; android:sspPrefix=&quot;&quot;/&gt;--&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 这样我们在要打开的activity中获取参数: Intent intent = getIntent(); Log.e(&quot;TAG&quot;, &quot;scheme:&quot; + intent.getScheme()); Uri uri = intent.getData(); if (uri != null) { Log.e(&quot;TAG&quot;, &quot;id:&quot; + uri.getQueryParamter(&quot;id&quot;)); Log.e(&quot;TAG&quot;, &quot;action:&quot; + uri.getQueryParamter(&quot;name&quot;)); } 需要注意的是：这种方式不支持webview的重定向操作，如果你对webview设置了重定向，那么就会返回:ERR_UNKNOWN_URL_SCHEME。 3.通过隐式意图 如果我们不想写js，又想要对webview进行重定向（大多数android开发都需要，因为要适配),那么就可以通过隐式意图基本上和第二种方式相同： 在html中: &lt;a href=&quot;android://?action=com.example.wudi.webviewdemo.baginfo&amp;id=123&quot;&gt; Take a QR code &lt;/a&gt; 与第二种方式不同的是：当中的链接是自己自定义的，如果你够聪明，就能拼写出优秀的uri，就像上边我拼的，因为项目中，需要和ios同步开发（ios用的LMBIOS），所以我定义了android来作为我的区分。 下边我们需要在清单文件中给activity设置action和category &lt;activity android:name=&quot;.DemoActivity&quot;&gt; &lt;!-- &lt;!— URI Scheme方式 -—&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.wudi.webviewdemo.baginfo&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 可以发现我设置的action和上边链接中action参数一致，下边就需要在webview重定向时，进行判断了 webview.setWebViewClient(new WebViewClient() { @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { // TODO Auto-generated method stub //返回值是true的时候控制去WebView打开，为false调用系统浏览器或第三方浏览器 if (url.startsWith(&quot;android&quot;)) { Uri uri = Uri.parse(url); String host = uri.getHost(); String action = uri.getQueryParameter(&quot;action&quot;); String id = uri.getQueryParameter(&quot;id&quot;); Intent intent = new Intent(); intent.setAction(action); intent.putExtra(&quot;id&quot;,id); startActivity(intent); } else { view.loadUrl(url); } return true; } }); 可以，看到，我的链接拼接方式可以直接把url转成uri，并获取参数，打开activity]]></content>
      <categories>
        <category>Android</category>
        <category>WebView</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android头部视差效果的实现方式]]></title>
    <url>%2F2016%2F07%2F13%2FAndroid%E5%A4%B4%E9%83%A8%E8%A7%86%E5%B7%AE%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[实现了类似qq空间头部的图片弹性效果，手指向下滑动头部图片展示出更多部分废话不说，上代码：自定义的ParallaxListView public class ParallaxListView extends ListView { private ImageView parallaxImageView; private int maxHeight; private int originalHeight; public ParallaxListView(Context context) { this(context, null); } public ParallaxListView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public ParallaxListView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } /** * 对外提供一个传入图片的方式 * * @param parallaxImageView */ public void setParallaxImageView(final ImageView parallaxImageView) { this.parallaxImageView = parallaxImageView; // 设置最大高度为图片的真实高度 maxHeight = parallaxImageView.getDrawable().getIntrinsicHeight(); // 利用视图树获取最初的高度 parallaxImageView.getViewTreeObserver().addOnGlobalLayoutListener( new OnGlobalLayoutListener() { /** * 该方法在完成布局的时候调用 */ @Override public void onGlobalLayout() { // 一般用完立即移除，因为只要有宽高变化，就会重新布局，会引起onGlobalLayout重新调用 parallaxImageView.getViewTreeObserver() .removeGlobalOnLayoutListener(this); originalHeight = parallaxImageView.getHeight(); } }); } /** * 重新overScrollBy方法 该方法是在listview滑动到头的时候调用，并且可以在该方法中获取滑动的距离 deltaY: 继续滑动的距离 * 正值：表示底部到头 负值：顶部到头 */ @SuppressLint(&quot;NewApi&quot;) @Override protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) { // 如果是顶部到头，并且是手指拖动到头，才让ImageView的高度增加 if (deltaY &lt; 0 &amp;&amp; isTouchEvent) { // 得到ImageView的新高度 int newHeight = parallaxImageView.getHeight() - deltaY / 3; // 对newHeight高度进行限制 if (newHeight &gt; maxHeight) newHeight = maxHeight; // 将新高度设置给imageview android.view.ViewGroup.LayoutParams params = parallaxImageView .getLayoutParams(); params.height = newHeight; parallaxImageView.setLayoutParams(params); } return super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent); } @SuppressLint(&quot;NewApi&quot;) @Override public boolean onTouchEvent(MotionEvent ev) { // 当手指抬起的时候执行一些逻辑 if (ev.getAction() == MotionEvent.ACTION_UP) { // 让ImageView高度缓慢恢复到初始设置的120 final ValueAnimator animator = ValueAnimator.ofInt( parallaxImageView.getHeight(), originalHeight); animator.addUpdateListener(new AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { // 获取动画当前的值 int value = (Integer) animator.getAnimatedValue(); android.view.ViewGroup.LayoutParams params = parallaxImageView .getLayoutParams(); params.height = value; parallaxImageView.setLayoutParams(params); } }); animator.setInterpolator(new OvershootInterpolator()); animator.setDuration(400); animator.start(); } return super.onTouchEvent(ev); } } ParallaxAdapter： public class ParallaxAdapter extends BaseAdapter { private Context context; public ParallaxAdapter(Context context) { this.context = context; } @Override public int getCount() { return 30; } @Override public Object getItem(int position) { return null; } @Override public long getItemId(int position) { return 0; } @Override public View getView(int position, View convertView, ViewGroup parent) { TextView tv = new TextView(context); tv.setText(&quot;哈哈哈&quot;+position); tv.setTextSize(30); tv.setTextColor(Color.BLACK); return tv; } } Activity中使用： public class MainActivity extends Activity { private ParallaxListView mPlv; private View headerView; private ImageView parallaxImageView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); } /** * 添加数据 */ private void initData() { mPlv.addHeaderView(headerView); mPlv.setParallaxImageView(parallaxImageView); mPlv.setAdapter(new ParallaxAdapter(getApplicationContext())); } /** * 添加布局 */ @SuppressLint(&quot;NewApi&quot;) private void initView() { mPlv = (ParallaxListView) findViewById(R.id.lv); //去掉阴影 mPlv.setOverScrollMode(AbsListView.OVER_SCROLL_NEVER); headerView = View.inflate(getApplicationContext(), R.layout.item_header, null); parallaxImageView = (ImageView) headerView.findViewById(R.id.iv); } }]]></content>
      <categories>
        <category>Android</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp接口拦截打印log的设置]]></title>
    <url>%2F2016%2F06%2F30%2FOkHttp%E6%8E%A5%E5%8F%A3%E6%8B%A6%E6%88%AA%E6%89%93%E5%8D%B0log%E7%9A%84%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[通常调试网络接口时都会将网络请求和响应相关数据通过日志的形式打印出来。OkHttp也提供了一个网络拦截器okhttp-logging-interceptor，通过它能拦截okhttp网络请求和响应所有相关信息（请求行、请求头、请求体、响应行、响应行、响应头、响应体）。 使用okhttp网络日志拦截器： compile &apos;com.squareup.okhttp3:logging-interceptor:3.5.0&apos; 定义拦截器中的网络日志工具 public class HttpLogger implements HttpLoggingInterceptor.Logger { @Override public void log(String message) { Log.d(&quot;HttpLogInfo&quot;, message); } } 初始化OkHttpClient，并添加网络日志拦截器 12345678910111213141516/*** 初始化okhttpclient.** @return okhttpClient*/private OkHttpClient okhttpclient() &#123; if (mOkHttpClient == null) &#123;trueHttpLoggingInterceptor logInterceptor = new HttpLoggingInterceptor(new HttpLogger());truelogInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);truemOkHttpClient = new OkHttpClient.Builder()true .connectTimeout(15, TimeUnit.SECONDS)true .addNetworkInterceptor(logInterceptor)true .build(); &#125; return mOkHttpClient;&#125; 打印出来的日志 拦截的网络请求日志信息1 拦截的网络请求日志信息2 拦截的网络请求日志信息3 注意:在给OkhttpClient添加网络请求拦截器的时候应该调用方法addNetworkInterceptor，而不是addInterceptor。因为有时候可能会通过cookieJar在header里面去添加一些持久化的cookie或者session信息。这样就在请求头里面就不会打印出这些信息。 看一下OkHttpClient调用拦截器的源码： Response getResponseWithInterceptorChain() throws IOException { // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { interceptors.addAll(client.networkInterceptors()); } interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest); } 在okhttp执行网络请求时，会先构造拦截链，此时是将所有的拦截器都放入一个ArrayList中，看源码就知道添加拦截器的顺序是： client.interceptors()， BridgeInterceptor， CacheInterceptor， ConnectInterceptor， networkInterceptors， CallServerInterceptor。 在通过拦截链执行拦截逻辑是按先后顺序递归调用的。如果是我们调用addInterceptor方法来添加HttpLoggingInterceptor拦截器，那么网络日志拦截器就会被添加到client.networkInterceptors()里面，根据添加到ArrayList中的顺序，执行拦截时会先执行HttpLoggingInterceptor，并打印出日志。然后才会执行CookieJar包装的拦截器BridgeInterceptor。这就导致我们添加header中的cookie等信息不会打印出来。 现在我们打印出了完整的日志，但是格式看起来很不舒服，下面我们来对打印出来的数据格式化。 我采用的是开源日志库looger来打印 加入依赖： compile &apos;com.orhanobut:logger:1.15&apos; 使用looger库的时候建议先封装一层，作为一个工具类。 public class LogUtil { /** * 初始化log工具，在app入口处调用 * * @param isLogEnable 是否打印log */ public static void init(boolean isLogEnable) { Logger.init(&quot;LogHttpInfo&quot;) .hideThreadInfo() .logLevel(isLogEnable ? LogLevel.FULL : LogLevel.NONE) .methodOffset(2); } public static void d(String message) { Logger.d(message); } public static void i(String message) { Logger.i(message); } public static void w(String message, Throwable e) { String info = e != null ? e.toString() : &quot;null&quot;; Logger.w(message + &quot;：&quot; + info); } public static void e(String message, Throwable e) { Logger.e(e, message); } public static void json(String json) { Logger.json(json); } } 我们还需要在Application调用初始化方法 // 初始化Looger工具 LogUtil.init(BuildConfig.LOG_DEBUG); 这时候我们继续写HttpLogger类 private class HttpLogger implements HttpLoggingInterceptor.Logger { private StringBuilder mMessage = new StringBuilder(); @Override public void log(String message) { // 请求或者响应开始 if (message.startsWith(&quot;--&gt; POST&quot;)) { mMessage.setLength(0); } // 以{}或者[]形式的说明是响应结果的json数据，需要进行格式化 if ((message.startsWith(&quot;{&quot;) &amp;&amp; message.endsWith(&quot;}&quot;)) || (message.startsWith(&quot;[&quot;) &amp;&amp; message.endsWith(&quot;]&quot;))) { message = formatJson(decodeUnicode(message)); } mMessage.append(message.concat(&quot;\n&quot;)); // 响应结束，打印整条日志 if (message.startsWith(&quot;&lt;-- END HTTP&quot;)) { LogUtil.d(mMessage.toString()); } } /** * 格式化json字符串 * * @param jsonStr 需要格式化的json串 * @return 格式化后的json串 */ public static String formatJson(String jsonStr) { if (null == jsonStr || &quot;&quot;.equals(jsonStr)) return &quot;&quot;; StringBuilder sb = new StringBuilder(); char last = &apos;\0&apos;; char current = &apos;\0&apos;; int indent = 0; for (int i = 0; i &lt; jsonStr.length(); i++) { last = current; current = jsonStr.charAt(i); //遇到{ [换行，且下一行缩进 switch (current) { case &apos;{&apos;: case &apos;[&apos;: sb.append(current); sb.append(&apos;\n&apos;); indent++; addIndentBlank(sb, indent); break; //遇到} ]换行，当前行缩进 case &apos;}&apos;: case &apos;]&apos;: sb.append(&apos;\n&apos;); indent--; addIndentBlank(sb, indent); sb.append(current); break; //遇到,换行 case &apos;,&apos;: sb.append(current); if (last != &apos;\\&apos;) { sb.append(&apos;\n&apos;); addIndentBlank(sb, indent); } break; default: sb.append(current); } } return sb.toString(); } /** * 添加space * * @param sb * @param indent */ private static void addIndentBlank(StringBuilder sb, int indent) { for (int i = 0; i &lt; indent; i++) { sb.append(&apos;\t&apos;); } } /** * http 请求数据返回 json 中中文字符为 unicode 编码转汉字转码 * * @param theString * @return 转化后的结果. */ public static String decodeUnicode(String theString) { char aChar; int len = theString.length(); StringBuffer outBuffer = new StringBuffer(len); for (int x = 0; x &lt; len; ) { aChar = theString.charAt(x++); if (aChar == &apos;\\&apos;) { aChar = theString.charAt(x++); if (aChar == &apos;u&apos;) { int value = 0; for (int i = 0; i &lt; 4; i++) { aChar = theString.charAt(x++); switch (aChar) { case &apos;0&apos;: case &apos;1&apos;: case &apos;2&apos;: case &apos;3&apos;: case &apos;4&apos;: case &apos;5&apos;: case &apos;6&apos;: case &apos;7&apos;: case &apos;8&apos;: case &apos;9&apos;: value = (value &lt;&lt; 4) + aChar - &apos;0&apos;; break; case &apos;a&apos;: case &apos;b&apos;: case &apos;c&apos;: case &apos;d&apos;: case &apos;e&apos;: case &apos;f&apos;: value = (value &lt;&lt; 4) + 10 + aChar - &apos;a&apos;; break; case &apos;A&apos;: case &apos;B&apos;: case &apos;C&apos;: case &apos;D&apos;: case &apos;E&apos;: case &apos;F&apos;: value = (value &lt;&lt; 4) + 10 + aChar - &apos;A&apos;; break; default: throw new IllegalArgumentException( &quot;Malformed \\uxxxx encoding.&quot;); } } outBuffer.append((char) value); } else { if (aChar == &apos;t&apos;) aChar = &apos;\t&apos;; else if (aChar == &apos;r&apos;) aChar = &apos;\r&apos;; else if (aChar == &apos;n&apos;) aChar = &apos;\n&apos;; else if (aChar == &apos;f&apos;) aChar = &apos;\f&apos;; outBuffer.append(aChar); } } else outBuffer.append(aChar); } return outBuffer.toString(); } } 最终效果 D/LogHttpInfo: ╔════════════════════════════════════════════════════════════════════════════════════════ D/LogHttpInfo: ║ RealInterceptorChain.proceed (RealInterceptorChain.java:92) D/LogHttpInfo: ║ HttpLoggingInterceptor.intercept (HttpLoggingInterceptor.java:266) D/LogHttpInfo: ╟──────────────────────────────────────────────────────────────────────────────────────── D/LogHttpInfo: ║ --&gt; POST http://op.juhe.cn/onebox/movie/video http/1.1 D/LogHttpInfo: ║ Content-Type: application/x-www-form-urlencoded D/LogHttpInfo: ║ Content-Length: 95 D/LogHttpInfo: ║ Host: op.juhe.cn D/LogHttpInfo: ║ Connection: Keep-Alive D/LogHttpInfo: ║ Accept-Encoding: gzip D/LogHttpInfo: ║ User-Agent: okhttp/3.5.0 D/LogHttpInfo: ║ D/LogHttpInfo: ║ key=a3d3a43fcc149b6ed8268b8fa41d27b7&amp;dtype=json&amp;q=%E9%81%97%E8%90%BD%E7%9A%84%E4%B8%96%E7%95%8C D/LogHttpInfo: ║ --&gt; END POST (95-byte body) D/LogHttpInfo: ║ &lt;-- 200 OK http://op.juhe.cn/onebox/movie/video (760ms) D/LogHttpInfo: ║ Server: nginx D/LogHttpInfo: ║ Date: Mon, 16 Jan 2017 09:36:35 GMT D/LogHttpInfo: ║ Content-Type: application/json;charset=utf-8 D/LogHttpInfo: ║ Transfer-Encoding: chunked D/LogHttpInfo: ║ Connection: keep-alive D/LogHttpInfo: ║ X-Powered-By: PHP/5.6.23 D/LogHttpInfo: ║ D/LogHttpInfo: ║ { D/LogHttpInfo: ║ &quot;reason&quot;:&quot;查询成功&quot;, D/LogHttpInfo: ║ &quot;result&quot;:{ ... D/LogHttpInfo: ║ }, D/LogHttpInfo: ║ &quot;error_code&quot;:0 D/LogHttpInfo: ║ } D/LogHttpInfo: ║ &lt;-- END HTTP (2994-byte body) D/LogHttpInfo: ╚══════════════════════════════════════════════════════════════════ 以上就是所有的设置了，下面来说一下怎么更改打印的log不同等级的颜色 流程： 1. File-&gt;Settings 或Ctrl + Alt +S 2. 找到 Editor -&gt; Colors &amp;Fonts -&gt; Android Logcat 或在上面的搜索框中输入Logcat 3. 点中Verbose , Info, Debug等选项，然后在后面将Use Inberited attributes 去掉勾选 4. 再将 Foreground 前的复选框选上，就可以双击后面的框框去选择颜色了 Apply–&gt;OK 对应颜色值： VERBOSE BBBBBB DEBUG 0070BB INFO 48BB31 WARN BBBB23 ERROR FF0006 ASSERT 8F0005 效果：]]></content>
      <categories>
        <category>Android</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中屏幕适配的方式]]></title>
    <url>%2F2016%2F05%2F27%2FAndroid%E4%B8%AD%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[android中屏幕适配的方式： 图片适配 根据不同手机屏幕的分辨率，加载不同文件夹下的图片 跟手机屏幕的像素密度有关系 像素密度又是什么呢？就是假如说，手机的屏幕是5英寸的，那么分辨率就是1280*720- 的，利用勾股定理，计算出斜边的值，再除以5， 计算出来的就是像素密度。根据这个像素密度，再确定加载哪个文件夹下的图片。 dimens.xml适配 这个主要是适配控件的宽高，就是在dimens.xml文件中设定空间的宽高，再在xml布局中引用dimens.xml问价中的值，假如想想要对固定手机屏幕分辨率进行设定，可以在res目录下，创建 values-1280 720 的目录，把dimens.xml文件复制过来更改里面的属性值，就可以了，这样的话，其他手机引用的就是普通的值，假如是 1280 720 的手机，就直接引用values-1280 720问价中的属性值了，但是要注意，1280 720的顺序不能写反了，大数一定写在前边 layout布局适配 就是在res下创建layout-1280*720的目录，再这里写布局文件，这样就大大增加了应用的体积，给用户的体验不好，不到万不得已的时候不用。 java代码适配，这个用的比较多，他可以设定空间的控件的宽高，也可以设定之间的距离 怎么样做到适配呢？首先要获取手机屏幕的宽高，再通过设定比例值，选择一个适配的手机，计算出宽高的比例值，（控件的宽/手机屏幕的宽），然后再在下需要设定值的地方，拿着求出来的手机的宽*这个我们算出来的比例值，就是适配的值了。再有就是pd–&gt;px px–&gt;pd就是在需要适配的地方，用dp–&gt;px的方式去设定值，因为在手机上展示都是px单位， 权重适配 权重适配就是用到了weight这个属性，他是设定显示比例的，一般不能达到我们的需求，所以在使用权重适配的时候，一般会结合其他的 适配方法一起使用]]></content>
      <categories>
        <category>Android</category>
        <category>适配</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android6.0新的权限机制]]></title>
    <url>%2F2016%2F05%2F02%2FAndroid6.0%E6%96%B0%E7%9A%84%E6%9D%83%E9%99%90%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[接触到了android6.0权限的几个坑，这里记录一下参考自：http://blog.csdn.net/lmj623565791/article/details/50709663 对于6.0以下的权限及在安装的时候，根据权限声明产生一个权限列表，用户只有在同意之后才能完成app的安装，造成了我们想要使用某个app，就要默默忍受其一些不必要的权限（比如是个app都要访问通讯录、短信等）。 而在6.0以后，我们可以直接安装，当app需要我们授予不恰当的权限的时候，我们可以予以拒绝。当然你也可以在设置界面对每个app的权限进行查看，以及对单个权限进行授权或者解除授权。 新的权限机制更好的保护了用户的隐私，Google将权限分为两类： 一类是Normal Permissions，这类权限一般不涉及用户隐私，是不需要用户进行授权的，比如手机震动、访问网络等； 另一类是Dangerous Permission，一般是涉及到用户隐私的，需要用户进行授权，比如读取sdcard、访问通讯录等。 Normal Permissions如下： ACCESS_LOCATION_EXTRA_COMMANDS ACCESS_NETWORK_STATE ACCESS_NOTIFICATION_POLICY ACCESS_WIFI_STATE BLUETOOTH BLUETOOTH_ADMIN BROADCAST_STICKY CHANGE_NETWORK_STATE CHANGE_WIFI_MULTICAST_STATE CHANGE_WIFI_STATE DISABLE_KEYGUARD EXPAND_STATUS_BAR GET_PACKAGE_SIZE INSTALL_SHORTCUT INTERNET KILL_BACKGROUND_PROCESSES MODIFY_AUDIO_SETTINGS NFC READ_SYNC_SETTINGS READ_SYNC_STATS RECEIVE_BOOT_COMPLETED REORDER_TASKS REQUEST_INSTALL_PACKAGES SET_ALARM SET_TIME_ZONE SET_WALLPAPER SET_WALLPAPER_HINTS TRANSMIT_IR UNINSTALL_SHORTCUT USE_FINGERPRINT VIBRATE WAKE_LOCK WRITE_SYNC_SETTINGS Dangerous Permissions: group:android.permission-group.CONTACTS permission:android.permission.WRITE_CONTACTS permission:android.permission.GET_ACCOUNTS permission:android.permission.READ_CONTACTS group:android.permission-group.PHONE permission:android.permission.READ_CALL_LOG permission:android.permission.READ_PHONE_STATE permission:android.permission.CALL_PHONE permission:android.permission.WRITE_CALL_LOG permission:android.permission.USE_SIP permission:android.permission.PROCESS_OUTGOING_CALLS permission:com.android.voicemail.permission.ADD_VOICEMAIL group:android.permission-group.CALENDAR permission:android.permission.READ_CALENDAR permission:android.permission.WRITE_CALENDAR group:android.permission-group.CAMERA permission:android.permission.CAMERA group:android.permission-group.SENSORS permission:android.permission.BODY_SENSORS group:android.permission-group.LOCATION permission:android.permission.ACCESS_FINE_LOCATION permission:android.permission.ACCESS_COARSE_LOCATION group:android.permission-group.STORAGE permission:android.permission.READ_EXTERNAL_STORAGE permission:android.permission.WRITE_EXTERNAL_STORAGE group:android.permission-group.MICROPHONE permission:android.permission.RECORD_AUDIO group:android.permission-group.SMS permission:android.permission.READ_SMS permission:android.permission.RECEIVE_WAP_PUSH permission:android.permission.RECEIVE_MMS permission:android.permission.RECEIVE_SMS permission:android.permission.SEND_SMS permission:android.permission.READ_CELL_BROADCASTS 可以通过adb shell pm list permissions -d -g进行查看。 其中上面的dangerous permissions，危险权限都是一组一组的。如果app运行在android 6.x的机器上，对于授权机制是这样的。如果你申请某个危险的权限，假设你的app早已被用户授权了同一组的某个危险权限，那么系统会立即授权，而不需要用户去点击授权。比如你的app对READ_CONTACTS已经授权了，当你的app申请WRITE_CONTACTS时，系统会直接授权通过。此外，对于申请时弹出的dialog上面的文本说明也是对整个权限组的说明，而不是单个权限（注意这个dialog是不能进行定制的）。 当然也不要对权限组过多的依赖，对每个危险权限都要进行正常流程的申请，因为在后期的版本中这个权限组可能会产生变化。]]></content>
      <categories>
        <category>Android</category>
        <category>适配</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>